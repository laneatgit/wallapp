{
  "name": "memoizejs",
  "version": "0.1.1",
  "description": "A faster JavaScript memoizer",
  "main": "memoize.js",
  "directories": {
    "test": "tests"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/addyosmani/memoize.js"
  },
  "keywords": [
    "memoize",
    "memoization",
    "cache"
  ],
  "author": {
    "name": "Addy Osmani",
    "email": "addyosmani@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/addyosmani/memoize.js/issues"
  },
  "homepage": "https://github.com/addyosmani/memoize.js",
  "readme": "## Memoize.js\n\n> A faster JavaScript memoizer\n\nWhilst not new by any means, memoization is a useful optimization technique for caching the results of function calls such that lengthy lookups or expensive recursive computations can be minimized where possible.\n\nThe basic idea is that if you can detect an operation has already been previously completed for a specific set of input values, the stored result can instead be returned instead of repeating the operation again.\n\nSome of the problems memoization can help optimize include: recursive mathematics, algorithmic caching of canvas animation and more generally, any problems which can be expressed as a set of calls to the same function with a combination of argument values that repeat.\n\n### Usage\n\nImagine having a function you want to memoize, like running the Fibbonacci sequence:\n\n```\nvar fib, fiborg;\n\nfiborg = fib = function (x) {\n  if(x < 2) return 1; else return fib(x-1) + fib(x-2);\n}\n```\n\nWe can then memoize it as follows:\n\n```\nfib = memoize(fiborg);\nfib(20);\n```\n\n### License\n\nReleased under an MIT license.",
  "readmeFilename": "README.md",
  "_id": "memoizejs@0.1.1",
  "_from": "memoizejs@~0.1.0"
}
